[
    /* MISC */
    {
        "name": "Script Template",
        "script": "-- Any variables outside the main functions are global! (As programmer perspective) The code only gets ran once!\n\n-- Gets called when the computer starts up\nfunction onLoad()\n\t\nend\n\n-- Gets called every tick\nfunction onUpdate( deltaTime )\n\t\nend\n\n-- Gets called when the computer error's out.\nfunction onError( errMsg )\n\t\nend\n\n-- Gets called when the computers code is saved.\nfunction onReload()\n\nend\n\n-- Gets called when the computer shuts down.\nfunction onDestroy()\n\t\nend"
    },
    {
        "name": "Encryiption Example - Base64",
        "script": "function onLoad()\n\t-- Message\n\tlocal msg = \"Hello World!\"\n\tprint(\"Message: \"..msg)\n\n\t-- Encoded Message\n\tlocal encodedMessage = sc.base64.encode(msg)\n\tprint(\"Encoded: \"..encodedMessage)\n\n\t-- Decoded Message\n\tlocal decodedMessage = sc.base64.decode(encodedMessage)\n\tprint(\"Decoded: \"..decodedMessage)\nend"
    },
    {
        "name": "Encryiption Example - MD5",
        "script": "function onLoad()\n\t-- Message\n\tlocal msg = \"Hello World!\"\n\tprint(\"Message: \"..msg)\n\n\t-- Encoded message\n\tlocal encodedMessage = sc.md5.sumhexa(msg)\n\tprint(\"MD5 Encoded: \"..encodedMessage)\n\n\t-- Stream example\n\tlocal stream = sc.md5.new()\n\tstream:update('some bytes')\n\tstream:update('some more bytes')\n\tstream:update('etc')\n\tprint(\"MD5 Stream Encoded:\"..sc.md5.tohex(stream:finish()))\nend"
    },
    {
        "name": "Encryiption Example - SHA256",
        "script": "function onLoad()\n\t-- Message\n\tlocal msg = \"Hello World!\"\n\tprint(\"Message: \"..msg)\n\n\t-- Encoded message\n\tlocal encodedMessage = sc.sha256.encode(msg)\n\tprint(\"SHA256 Encoded: \"..encodedMessage)\nend"
    },

    /* TERMINAL */
    {
        "name": "Terminal Example",
        "script": "-- Get terminal component\nlocal terminal = sc.getTerminals()[1]\n\nfunction onLoad()\n\t-- Clears the terminal and writes initial message\n\tterminal.clear()\n\tterminal.send(\"#3A96DDComputer: Send a input and il echo it back to you!\")\nend\n\nfunction onUpdate()\n\t-- Checks to see if there has been any user inputs\n\tif terminal.receivedInputs() then\n\t\t-- Get message and send it back with \">\" at the start\n\t\tlocal text = terminal.getInput()\n\n\t\tterminal.send(\"> \"..text)\n\tend\nend\n\nfunction onDestroy()\n\t-- Clear terminal and input history\n\tterminal.clear()\n\tterminal.clearInputHistory()\nend"
    },
    
    /* HARDDRIVE */
    {
        "name": "Harddrive Write Example",
        "script": "-- Get harddrive component\nlocal harddrive = sc.getDrives()[1]\n\n-- Data to be stored inside the harddrive\nlocal data = {} \n\nfunction onLoad()\n\t-- Save the data\n\tharddrive.save(data)\n\t\n\tprint(\"Saved Data!\")\nend"
    },
    {
        "name": "Harddrive Read Example",
        "script": "-- Get harddrive component\nlocal harddrive = sc.getDrives()[1]\n\nfunction onLoad()\n\t-- Get the data stored in the harddrive and make it a string\n\tlocal data = harddrive.load()\n\tlocal jsonString = sm.json.writeJsonString(data)\n\n\tprint(jsonString)\nend"
    },
    
    /* HOLOGRAM */
    {
        "name": "Hologram Cube Example",
        "script": "-- Get hologram component\nlocal hologram = sc.getHolograms()[1]\n\n-- Set the holograms initial parameters\nlocal scale = sm.vec3.new(1,1,1)\nlocal position = sm.vec3.new(0,1,0)\nlocal rotation = sm.vec3.new(45,25,15)\nlocal color = sc.color.random0to1()\n\n-- Create the hologram and get its ID\nfunction onLoad()\n\tid = hologram.createCube(position, rotation, scale, color)\nend\n\nfunction onUpdate()\n\t-- Get the hologram object with its ID\n\tlocal object = hologram.getObject(id)\n\n\t-- Set the holograms rotation\n\tobject.setRotation(rotation)\n\t-- Step the rotation by 1 degree in each axis\n\trotation = rotation + sm.vec3.one()\nend"
    },
    {
        "name": "Hologram Custom Object Example",
        "script": "-- Get hologram component\nlocal hologram = sc.getHolograms()[1]\n\n-- Set the holograms initial parameters\nlocal uuid = \"6ad29c0e-8209-4dca-9133-20d7a2fc2d63\"\nlocal scale = sm.vec3.new(1,1,1)\nlocal position = sm.vec3.new(0,1,0)\nlocal rotation = sm.vec3.new(45,25,15)\nlocal color = sm.color.new(\"4A4A4A\")\n\n-- Create the hologram object\nfunction onLoad()\n\thologram.createCustomObject(uuid, position, rotation, scale, color)\nend"
    },
    {
        "name": "Hologram Atom Example",
        "script": "-- Get hologram component\nlocal hologram = sc.getHolograms()[1]\n\n-- Create Static variables\nlocal protonColor = sm.color.new(\"ff0000\")\nlocal neutronColor = sm.color.new(\"00ff00\")\nlocal electronColor = sm.color.new(\"ffffff\")\nlocal datumPosition = sm.vec3.new(0, 1, 0)\n\n-- Create tables for storing hologram objects\nlocal nucleusObjects = {}\nlocal electronObjects = {}\n\n-- Create average position used for centering the rotation of the electrons\nlocal averagePosition = sm.vec3.zero()\n\n-- Generates a random rotation direction for electrons\nlocal function generateRandom()\n\tlocal rand = math.random(1, 2)\n\n\treturn math.random(0, 1) == 1 and sm.vec3.new(0, math.rad(10), 0) or sm.vec3.new(0, math.rad(-10), 0)\nend\n\nfunction onLoad()\n\t-- Get the ammount of protons and neutrons in the nucleus\n\tlocal nucleusCount = math.random(2, 5)\n\tlocal electronCount = math.random(1, 3)\n\n\t-- Loop for every nucleus object\n\tfor i = 1, nucleusCount do\n\t\t-- Generates a random bool to make the object a proton and generates a random offset position\n\t\tlocal isProton = math.random(0, 1) == 1\n\t\tlocal randOffset = sm.vec3.new(math.random(), math.random(), math.random())\n\t\n\t\t-- Set the objects parameters\n\t\tlocal position = datumPosition + randOffset - randOffset / 2\n\t\tlocal rotation = sm.vec3.zero()\n\t\tlocal scale = sm.vec3.one()\n\t\tlocal color = isProton and protonColor or neutronColor\n\n\t\t-- Create the object and add it to its respective table, along with data needed for modifications\n\t\tnucleusObjects[#nucleusObjects + 1] = {\n\t\t\tid = hologram.createSphere(position, rotation, scale, color),\n\t\t\tposition = position\n\t\t}\n\n\t\t-- Update the average position with the random offset\n\t\taveragePosition = averagePosition + position\n\tend\n\n\t-- Complete the average\n\taveragePosition = averagePosition / nucleusCount\n\n\t-- Loop for every electron object\n\tfor i = 1, electronCount do\n\t\t-- Set the objects parameters\n\t\tlocal position = sm.vec3.new(i + 0.5, 0, 0) + averagePosition\n\t\tlocal rotation = sm.vec3.zero()\n\t\tlocal scale = sm.vec3.one() / 10\n\t\n\t\t-- Create the object and add it to its respective table, along with data needed for modifications\n\t\telectronObjects[#electronObjects + 1] = {\n\t\t\tid = hologram.createSphere(position, rotation, scale, electronColor),\n\t\t\tposition = position,\n\t\t\torbitDirection = generateRandom() -- dictates the direction of rotation\n\t\t}\n\tend\nend\n\nfunction onUpdate()\n\t-- Loop through every nucleus object\n\tfor i, objectData in pairs(nucleusObjects) do\n\t\t-- Get the object and create a noise offset for vibration\n\t\tlocal object = hologram.getObject(objectData.id)\n\t\tlocal noiseOffset = sm.vec3.new(math.random() / 10, math.random() / 10, math.random() / 10)\n\n\t\t-- Set the new position\n\t\tobject.setPosition(objectData.position + noiseOffset - noiseOffset / 2)\n\tend\n\n\t-- Loop through every electron object\n\tfor i, objectData in pairs(electronObjects) do\n\t\t-- Get the object\n\t\tlocal object = hologram.getObject(objectData.id)\n\n\t\t-- Get the direction from the current position to the average position and rotate based on the orbit direction\n\t\tlocal direction = averagePosition - objectData.position\n\t\tlocal newDirection = direction:rotateY(objectData.orbitDirection.y)\n\n\t\t-- Create the new electron position with the new direction\n\t\tlocal newPosition = averagePosition - newDirection\n\n\t\t-- Update the objects position and update the tables saved position\n\t\tobject.setPosition(newPosition)\n\t\tobjectData.position = newPosition\n\tend\nend"
    },
    
    /* RADAR */
    {
        "name": "Radar Example",
        "script": "-- Get radar component\nlocal radar = sc.getRadars()[1]\n\n-- Set static variables\nlocal vAngle = 35\nlocal hAngle = 35\n\nfunction onLoad()\n\t-- Set scan angles\n\tradar.setVerticalScanAngle(vAngle)\n\tradar.setHorizontalScanAngle(hAngle)\nend\n\nfunction onUpdate()\n\t-- Get all targets\n\tlocal targets = radar.getTargets()\n\n\tprint(\"Total Targets: \"..tostring(#targets))\n\t\n\t-- Loop through each target\n\tfor _, target in pairs(targets) do\n\t\t-- Round targets world position\n\t\tlocal roundedPosition = sm.vec3.new(\n\t\t\tmath.floor(target.position.x),\n\t\t\tmath.floor(target.position.y),\n\t\t\tmath.floor(target.position.z)\n\t\t)\n\n\t\t-- Print target data \n\t\tprint(tostring(roundedPosition)..\" | \"..tostring(target.surfaceArea))\n\tend\nend"
    },
    
    /* NETWORK PORT */
    {
        "name": "Network Port Send Example",
        "script": "-- Get network port component\nlocal networkPort = sc.getNetworkPorts()[1]\n\nfunction onLoad()\n\t-- Check to see if it has a connection\n\tif not networkPort.hasConnection() then\n\t\tprint(\"No connection found!\")\n\t\treturn\n\tend\n\n\t-- Send the data\n\tnetworkPort.sendPacket(\"Hello World!\")\n\tprint(\"Sent packet!\")\nend"
    },
    {
        "name": "Network Port Recieve Example",
        "script": "-- Get network port component\nlocal networkPort = sc.getNetworkPorts()[1]\n\nfunction onLoad()\n\t-- Check to see if it has a connection\n\tif not networkPort.hasConnection() then\n\t\tprint(\"No connection found!\")\n\t\treturn\n\tend\n\n\t-- If there is a recieved packet then print it\n\tif networkPort.getTotalPackets() > 0 then\n\t\tlocal packet = networkPort.receivePacket()\n\t\tprint(\"received \"..tostring(packet))\n\telse\n\t\tprint(\"No packets received!\")\n\tend\nend"
    },
    
    /* DISPLAY */
    {
        "name": "Display Touch Screen Example",
        "script": "-- Get display component\nlocal display = sc.getDisplays()[1]\n\nfunction onLoad()\n\t-- Enable touch screen on display\n\tdisplay.enableTouchScreen(true)\nend\n\nfunction onUpdate()\n\t-- Get the players touch screen data\n\tlocal data = display.getTouchData()\n\n\t-- Check if there is someone touching the screen and they havent released\n\tif data and data.state ~= 3 then\n\t\t-- Draw a pixel at the touch position with a random color\n\t\tdisplay.drawPixel(data.x, data.y, sc.color.random0to1())\n\tend\n\t\n\t-- Update the display()\n\tdisplay.update()\nend\n\nfunction onDestroy()\n\t-- Clear and update the display()\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    {
        "name": "Display Mandlebrot Fractal Example",
        "script": "-- Get display component\nlocal display = sc.getDisplays()[1]\n\n-- Get the connected display's width and height\nlocal width, height = display.getDimensions()\n\n--[[\n\tSome recommended values to try:\n\n\tmaxIterations = 1000\n\tzoom = 20000\n\toffsetX = -0.7497\n\toffsetY = 0.0315\n]]\n\n-- Function to draw a Mandelbrot fractal on the display\nfunction drawFractal()\n\t-- Set variables specific for the final image\n\tlocal maxIterations = 200 -- Maximum iterations per pixel, determines the detail and accuracy of the fractal\n\tlocal zoom = 1 -- Zoom multiplier, adjusts the scale of the fractal\n\tlocal offsetX = 0 -- X-axis offset for the fractal's center\n\tlocal offsetY = 0 -- Y-axis offset for the fractal's center\n\tlocal pixelTbl = {} -- create the final pixel table\n\n\t-- Loop through every pixel on the display\n\tfor x = 1, width do\n\t\tfor y = 1, height do\n\t\t\t-- Convert pixel coordinates (x, y) to complex plane coordinates (zx, zy)\n\t\t\tlocal zx, zy = (x - width / 2) / (0.5 * zoom * width) + offsetX, (y - height / 2) / (0.5 * zoom * height) + offsetY\n\t\t\tlocal cRe, cIm = zx, zy  -- The real and imaginary parts of the initial complex number\n\t\t\tlocal iteration = 0  -- Iteration counter\n\n\t\t\t-- Iterate to determine if the point belongs to the Mandelbrot set\n\t\t\twhile (zx * zx + zy * zy < 4) and (iteration < maxIterations) do\n\t\t\t\tlocal newZx = zx * zx - zy * zy + cRe  -- Calculate the new real part\n\t\t\t\tlocal newZy = 2 * zx * zy + cIm  -- Calculate the new imaginary part\n\t\t\t\tzx, zy = newZx, newZy  -- Update zx and zy for the next iteration\n\t\t\t\titeration = iteration + 1  -- Increment the iteration counter\n\t\t\tend\n\n\t\t\t-- Determine the color based on the number of iterations\n\t\t\tlocal brightness = iteration / maxIterations\n\t\t\tlocal color\n\n\t\t\t-- If the point is in the set (reached max iterations), color it black\n\t\t\tif iteration == maxIterations then\n\t\t\t\tcolor = sm.color.new(0, 0, 0)\n\t\t\telse\n\t\t\t\t-- Otherwise, map the iteration count to a grayscale brightness\n\t\t\t\tcolor = sm.color.new(brightness, brightness, brightness) * 2  -- Adjust brightness level as needed\n\t\t\tend\n\n\t\t\t-- Add the pixel data to the pixel table\n\t\t\tpixelTbl[#pixelTbl + 1] = {x = x, y = y, scale = {x = 1, y = 1}, color = color}\n\t\tend\n\tend\n\t\n\t-- Draw the pixel table\n\tdisplay.drawFromTable(pixelTbl)\nend\n\nfunction onLoad()\n\t--Draw the fractal and update the display\n\tdrawFractal()\n\tdisplay.update()\nend\n"
    },
    {
        "name": "Display Optimization Tester",
        "script": "-- Warning! This can get very laggy on high pixel count displays, do this at your own risk\n\n-- Get display component\nlocal display = sc.getDisplays()[1]\n\n-- Get connected displays width and height\nlocal width, height = display.getDimensions()\n\nfunction onLoad()\n\t-- Loop through every pixel\n\tfor x = 1, width do\n\t\tfor y = 1, height do\n\t\t\t-- Draw a pixel at the current location with a random color\n\t\t\tdisplay.drawPixel(x, y, sc.color.random0to1())\n\t\tend\n\tend\n\t\n\t-- Update the display\n\tdisplay.update()\nend"
    },
    {
        "name": "Display Noise Generator",
        "script": "-- Get display component\nlocal display = sc.getDisplays()[1]\n\n-- Get connected displays width and height\nlocal width, height = display.getDimensions()\n\n-- Function that generates a random 10 digit seed\nlocal function generateSeed()\n\tlocal string = \"\"\n\n\tfor i = 1, 10 do\n\t\tstring = string..tostring(math.random(0, 9))\n\tend\n\n\treturn tonumber(string)\nend\n\nfunction onLoad()\n\t-- Generate a seed\n\tlocal seed = generateSeed()\n\n\t-- Loop through all pixels\n\tfor x = 1, width, 1 do\n\t\tfor y = 1, height, 1 do\n\t\t\t-- Draw a pixel based of a octaveNoise2d output\n\t\t\tdisplay.drawPixel(x, y, sc.color.newSingular(sm.noise.octaveNoise2d(x, y, 7.5, seed)))\n\t\tend\n\tend\n\n\t-- Update it.\n\tdisplay.update()\nend\n\nfunction onDestroy()\n\t-- Clear and update the display\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    {
        "name": "Display Rotating Cube Example",
        "script": "-- Get display component (128 x 128 recommended) \nlocal display = sc.getDisplays()[1]\n\n-- Get width and height\nlocal width, height = display.getDimensions()\n\n-- Initialise varaibles and create a random color\nlocal cubeSize = math.min(width, height) / 2  -- Scale of the cube size\nlocal angleX, angleY = 0, 0  -- Initial angles for rotation\nlocal centerX, centerY = width / 2, height / 2  -- Center of the display\nlocal rotationSpeed = 0.02  -- Speed of rotation\nlocal color = sc.color.random0to1()\n\n-- Define the 8 vertices of the cube\nlocal vertices = {\n\tsm.vec3.new(-1, -1, -1),\n\tsm.vec3.new(1, -1, -1),\n\tsm.vec3.new(1, 1, -1),\n\tsm.vec3.new(-1, 1, -1),\n\tsm.vec3.new(-1, -1, 1),\n\tsm.vec3.new(1, -1, 1),\n\tsm.vec3.new(1, 1, 1),\n\tsm.vec3.new(-1, 1, 1)\n}\n\n-- Define all cube edges\nlocal edges = {\n\t{1, 2}, {2, 3}, {3, 4}, {4, 1},  -- Edges of the front face\n\t{5, 6}, {6, 7}, {7, 8}, {8, 5},  -- Edges of the back face\n\t{1, 5}, {2, 6}, {3, 7}, {4, 8}   -- Connecting edges between front and back faces\n}\n\nfunction projectVertex(vertex)\n\t-- Simple perspective projection\n\tlocal scale = cubeSize / (vertex.z + 3)\n\tlocal x = vertex.x * scale + centerX\n\tlocal y = vertex.y * scale + centerY\n\n\t-- Clamp and round the coordinates\n\tx = sm.util.clamp(math.floor(x + 0.5), 1, width)\n\ty = sm.util.clamp(math.floor(y + 0.5), 1, height)\n\n\treturn x, y\nend\n\nfunction onUpdate()\n\t-- Clear the display\n\tdisplay.clear()\n\n\t-- Create projected verticies table\n\tlocal projectedVertices = {}\n\t\n\t-- Loop through each verticy\n\tfor i = 1, #vertices do\n\t\t-- Get the current verticy and rotate it based on the x and y angles\n\t\tlocal rotatedVertex = vertices[i]\n\t\trotatedVertex = rotatedVertex:rotateX(angleX)\n\t\trotatedVertex = rotatedVertex:rotateY(angleY)\n\t\t\n\t\t-- Project the rotated vertex to 2D screen space and add to the table\n\t\tlocal x, y = projectVertex(rotatedVertex)\n\t\tprojectedVertices[i] = {x, y}\n\tend\n\t\n\t-- Loop through each edge\n\tfor i = 1, #edges do\n\t\t-- Get the verticies that correspond to each stored edge\n\t\tlocal v1 = projectedVertices[edges[i][1]]\n\t\tlocal v2 = projectedVertices[edges[i][2]]\n\t\t\n\t\t-- Draw a line between the 2 coordinates\n\t\tdisplay.drawLine(v1[1], v1[2], v2[1], v2[2], color)\n\tend\n\n\t-- Update the display\n\tdisplay.update()\n\n\t-- Increment rotation angles\n\tangleX = angleX + rotationSpeed\n\tangleY = angleY + rotationSpeed\nend"
    },
    {
        "name": "Display Image Generation Example",
        "script": "-- The example image is 256 x 256, so please use a 256 x 256 display!\n-- Get the display component\nlocal display = sc.getDisplays()[1]\ndisplay.setOptimizationThreshold(0.02)\n\nlocal width, height = display.getDimensions()\n\n-- Generate the image and update the display\ndisplay.loadImage(width, height, \"example.json\")\ndisplay.update()"
    },
    {
        "name": "Display Video Drawer (Black And White)",
        "script": "local math_floor = math.floor\n\nlocal display = sc.getDisplays()[1]\nlocal drawFilledRect = display.drawFilledRect\nlocal videoData = sm.json.open(\"\") -- File path to video here, check out DisplayVideos folder!\nlocal width, height = display.getDimensions()\n\nlocal frameCount = 0\nlocal fps = 30\nlocal actualFPS = fps / 40\nlocal pixelCounter = 1\nlocal whiteColor = sm.color.new(1, 1, 1)\n\n-- Turns a coordinate number that is stored in the json into x and y\nfunction indexToCoordinate(index, width)\n\treturn (index - 1) % width + 1, math_floor((index - 1) / width) + 1\nend\n\n--Renders a frame by parsing video data structure\nfunction renderFrame()\n\tlocal length = videoData[pixelCounter]\n\n\tif not length then\n\t\tpixelCounter = 1\n\t\tlength = videoData[pixelCounter]\n\tend\n\t\n\tpixelCounter = pixelCounter + 1\n\n\tif length == 0 then return end \n\n\tfor _ = 1, length do\n\t\tlocal x, y = indexToCoordinate(videoData[pixelCounter], width)\n\t\tpixelCounter = pixelCounter + 1\n\n\t\tlocal sx, sy = indexToCoordinate(videoData[pixelCounter], width)\n\t\tpixelCounter = pixelCounter + 1\n\n\t\tdrawFilledRect(x, y, sx, sy, whiteColor)\n\tend\nend\n\n--Times the update according with the fps specified\nfunction onUpdate()\n\tif math_floor(frameCount) > math_floor(frameCount - actualFPS) then\n\t\tdisplay.clear()\n\n\t\trenderFrame()\n\t\t\n\t\tdisplay.update()\n\tend\n\n\tframeCount = frameCount + actualFPS\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    {
        "name": "Display Video Drawer (Full Color)",
        "script": "local math_floor = math.floor\n\nlocal display = sc.getDisplays()[1]\nlocal drawFilledRect = display.drawFilledRect\nlocal videoData = sm.json.open(\"\") -- File path to video here, check out DisplayVideos folder!\nlocal width, height = display.getDimensions()\n\nlocal frameCount = 0\nlocal fps = 30\nlocal actualFPS = fps / 40\nlocal pixelCounter = 1\n\n-- Turns a coordinate number that is stored in the json into x and y\nfunction indexToCoordinate(index, width)\n\treturn (index - 1) % width + 1, math_floor((index - 1) / width) + 1\nend\n\n--Renders a frame by parsing video data structure\nfunction renderFrame()\n\tlocal length = videoData[pixelCounter]\n\n\tif not length then\n\t\tpixelCounter = 1\n\t\tlength = videoData[pixelCounter]\n\tend\n\t\n\tpixelCounter = pixelCounter + 1\n\n\tif length == 0 then return end \n\n\tfor _ = 1, length do\n\t\tlocal x, y = indexToCoordinate(videoData[pixelCounter], width)\n\t\tpixelCounter = pixelCounter + 1\n\n\t\tlocal sx, sy = indexToCoordinate(videoData[pixelCounter], width)\n\t\tpixelCounter = pixelCounter + 1\n\n\t\tdrawFilledRect(x, y, sx, sy, videoData[pixelCounter])\n\t\tpixelCounter = pixelCounter + 1\n\tend\nend\n\n--Times the update according with the fps specified\nfunction onUpdate()\n\tif math_floor(frameCount) > math_floor(frameCount - actualFPS) then\n\t\tdisplay.clear()\n\n\t\trenderFrame()\n\t\t\n\t\tdisplay.update()\n\tend\n\n\tframeCount = frameCount + actualFPS\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    
    /* CAMERA + DISPLAY */
    {
        "name": "Picture Example (Display + Camera)",
        "script": "-- Get display and camera components\nlocal display = sc.getDisplays()[1]\nlocal camera = sc.getCameras()[1]\n\n-- Get connected displays width and height\nlocal width, height = display.getDimensions()\n\n-- Set camera parameters\ncamera.setFov(50) --Fov in degrees\ncamera.setRange(1000) --Range in meters\n\nfunction onLoad()\n\t-- Draw the frame to the display\n\tcamera.frame(display)\n\n\t-- Update the display\n\tdisplay.update()\nend"
    },
    {
        "name": "Custom Example (Display + Camera)",
        "script": "-- Get display and camera components\nlocal display = sc.getDisplays()[1]\nlocal camera = sc.getCameras()[1]\n\n-- Get connected displays width and height\nlocal width, height = display.getDimensions()\n\n-- Set camera parameters\ncamera.setFov(50) --Fov in degrees\ncamera.setRange(1000) --Range in meters\n\n-- Create the drawer function that the customFrame will use to color pixels\nlocal function drawer(hit, result, x, y)\n\tlocal color = sm.color.new(\"000000\")\n\n\tif hit then\n\t\tcolor = sm.color.new(1, 1, 1) * (1 - result.fraction)\n\tend\n\n\treturn color\nend\n\nfunction onLoad()\n\t-- Draw the frame to the display\n\tcamera.customFrame(display, drawer)\n\n\t-- Update the display\n\tdisplay.update()\nend"
    },
    {
        "name": "Video Example (Display + Camera)",
        "script": "-- Get display and camera components\nlocal display = sc.getDisplays()[1]\nlocal camera = sc.getCameras()[1]\n\n-- Get connected displays width and height\nlocal width, height = display.getDimensions()\n\n-- Set camera parameters\ncamera.setFov(50) --Fov in degrees\ncamera.setRange(250) --Range in meters\n\n-- Set display parameters\ndisplay.setOptimizationThreshold(0.05) -- Sets the image compression\n\nfunction onUpdate()\n\t-- Draw the video slices to the display\n\tcamera.video(display, 4) -- 4 slices of the display will be drawn per tick\n\n\t-- Update the display\n\tdisplay.update()\nend"
    },
    
    /* SPEAKER */
    {
        "name": "Speaker Example",
        "script": "local speaker = sc.getSpeakers()[1]\n\nfunction onLoad()\n\t-- See https://github.com/Vajdani/sm_docs/blob/master/Lists/Audio.json for full list\n\tspeaker.playSound(\"event:/music/robotheads/dance/dancebass\")\nend"
    },
    
    /* KEYBOARD + DISPLAY */
    {
        "name": "Typing Example (Display + Keyboard)",
        "script": "-- Get keyboard and display components\nlocal keyboard = sc.getKeyboards()[1]\nlocal display = sc.getDisplays()[1]\n\n-- Set globals\nfunction onLoad()\n\tlastKeystroke = \"\"\n\ttext = \"\"\nend\n\nfunction onUpdate()\n\t-- Get keyboards keystroke and press data\n\tlocal keystroke = keyboard.getLatestKeystroke()\n\tlocal pressed = keyboard.isPressed()\n\n\t-- Create variables for rapid press\n\tlocal rapidPress\n\tlocal clock = os.clock()\n\n\t-- Determine if the user is holding a key, if so then rapid press\n\tif pressed then\n\t\tif keystroke == lastKeystroke then\n\t\t\tif not pressClock then\n\t\t\t\tpressClock = clock\n\t\t\tend\n\n\t\t\tif pressClock + 0.3 <= clock then\n\t\t\t\trapidPress = true\n\t\t\tend\n\t\telse\n\t\t\trapidPress = false\n\t\t\tpressClock = nil\n\t\tend\n\telse\n\t\trapidPress = false\n\t\tpressClock = nil\n\t\tnotPress = true\n\tend\n\n\t-- Determine if a keystroke should be made\n\tif (pressed and notPress or keystroke ~= lastKeystroke) or rapidPress then\n\t\tlastKeystroke = keystroke\n\t\tnotPress = false\n\n\t\t-- If the keystroke is a backspace then remove the last char in the string, else add the current keystroke\n\t\tif keystroke == \"backSpace\" then\n\t\t\tif #text > 0 then\n\t\t\t\ttext = text:sub(1, #text - 1)\n\t\t\tend\n\t\telse\n\t\t\ttext = text..keystroke\n\t\tend\n\t\t\n\t\t-- Clear and update the display with the new string\n\t\tdisplay.clear()\n\t\tdisplay.drawText(2, 2, text, \"eeeeee\")\n\t\tdisplay.update()\n\tend\nend\n\nfunction onDestroy()\n\t-- Clear and update the display\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    
    /* MOTOR */
    {
        "name": "Motor example",
        "script": "-- Get motor component\nlocal motor = sc.getMotors()[1]\n\n-- Set the bearing speed and torque to random values\nfunction onLoad()\n\tmotor.setBearingSpeed(math.random(100, 1000))\n\tmotor.setTorque(math.random(100, 1000))\nend"
    },
    
    /* LASER */
    {
        "name": "Laser Example",
        "script": "-- Get laser component\nlocal laser = sc.getLasers()[1]\n\n-- Set static variables\nlocal distance = 100\n\n-- Set the lasers max distance\nfunction onLoad()\n\tlaser.setDistance(distance) -- Distance is in Meters\nend\n\nfunction onUpdate()\n\t-- Get the lasers raycast data\n\tlocal hit, result = laser.getLaserData()\n\n\t-- If the ray has hit something\n\tif hit then\n\t\t-- Multiply the max distance by the fraction to get the ray's distance travelled\n\t\tlocal roundedDistance = math.floor(result.fraction * distance)\n\t\n\t\t-- Print distance\n\t\tprint(\"Hit! Distance is \"..roundedDistance.. \" Meter(s)\")\n\tend\nend"
    },
        
    /* GPS */
    {
        "name": "GPS Example",
        "script": "-- Get GPS component\nlocal GPS = sc.getGPSs()[1]\n\nfunction onUpdate()\n\t-- Get the GPS's data\n\tlocal data = GPS.getGPSData()\n\n\t-- Print out the current speed\n\tprint(\"Current Speed: \"..math.floor(data.speed)..\" m/s\")\nend\n"
    },

    /* REGISTERS */
    {
        "name": "Register Addition Example",
        "script": "-- 2 Input and 1 output register needed, name the 2 input registers \"input1\" and \"input2\" respectivley, name the output register \"output\"\n-- This works best with putting things like modpack numbers into the registers, however you can do stuff like binary\n\nfunction onUpdate()\n\t-- Get the values in each register\n\tlocal input1 = sc.getReg(\"input1\")\n\tlocal input2 = sc.getReg(\"input2\")\n\n\t-- Set the output register with the new number\n\tsc.setReg(\"output\", input1 + input2) -- Can be any maths operation\nend\n"
    },
    {
        "name": "Register Clock Example",
        "script": "-- 1 output register needed, name the register \"output\"\n\n-- Set the power varaible\nlocal power = 0\n\nfunction onUpdate()\n\t-- Set the current power\n\tsc.setReg(\"output\", power)\n\n\t-- Flip flop the power between 0 - 1, this pulses the register at 20Hz\n\tpower = power == 0 and 1 or 0\nend"
    },

    /* LIGHT */
    {
        "name": "Rainbow Light Example",
        "script": "-- Get the light\nlocal light = sc.getLights()[1]\n\n-- Table of rainbow colors in RGB (normalized 0 to 1)\nlocal rainbowColors = {\n\tsm.color.new(1, 0, 0), -- Red\n\tsm.color.new(1, 0.5, 0), -- Orange\n\tsm.color.new(1, 1, 0), -- Yellow\n\tsm.color.new(0, 1, 0), -- Green\n\tsm.color.new(0, 0, 1), -- Blue\n\tsm.color.new(0.29, 0, 0.51), -- Indigo\n\tsm.color.new(0.56, 0, 1) -- Violet\n}\n\n-- We put this in a function so that theres a duplicate at the first color at the end.\nlocal function generateGradient()\n\t-- Clone the table\n\tlocal fullRainbow = rainbowColors\n\ttable.insert(fullRainbow, rainbowColors[1]) -- Add the first color to the end\n\n\t-- Generate a color gradient and return it\n\treturn sc.color.generateGradient(fullRainbow, 40 * 5)\nend\n\n-- The rainbow\nlocal gradient = generateGradient()\nlocal index = 1 -- The index of the gradient table\n\nfunction onUpdate()\n\t-- Increase index by 1 every time\n\tindex = index + 1\n\n\t-- Reset to 1 if it exceeds the gradient table\n\tif index > #gradient then\n\t\tindex = 1\n\tend\n\n\t-- Get the selected gradient color and change the light's color to that\n\tlight.setColor(gradient[index])\nend"
    },

    /* ASCFonts */
    {
        "name": "True TTF Font Rendering Example",
        "script": "-- CONFIG --\n\n-- These configs work fine with a 512x512 display.\n\n-- The font to use\nlocal fontName = \"Futura\"\n\n-- The text to draw.\nlocal text = \"Hello World!\"\n\n-- The size of the font\nlocal fontSize = 50 \n\n-- SOURCE CODE --\n\n-- Get the display and it's dimensions.\nlocal display = sc.getDisplays()[1]\nlocal displayWidth, displayHeight = display.getDimensions()\n\n-- These 2 variables are used for rotation and font size\nlocal rotationSinWave = 0\nlocal fontSizeSinWave = 0\n\n-- Colors of the rainbow\nlocal rainbowColors = {\n\tsm.color.new(1, 0, 0), -- Red\n\tsm.color.new(1, 0.5, 0), -- Orange\n\tsm.color.new(1, 1, 0), -- Yellow\n\tsm.color.new(0, 1, 0), -- Green\n\tsm.color.new(0, 0, 1), -- Blue\n\tsm.color.new(0.29, 0, 0.51), -- Indigo\n\tsm.color.new(0.56, 0, 1) -- Violet\n}\nrainbowColors[#rainbowColors+1] = rainbowColors[1] -- Add red at the end so it doesnt instantly go from Violet to Red.\n\n-- Generate the gradient\nlocal gradient = sc.color.generateGradient(rainbowColors, 100)\nlocal gradientIndex = 1 -- The gradient index.\n\nfunction onUpdate()\n\t-- Calculate the rotation\n\tlocal rotation = math.sin(rotationSinWave) * 11\n\trotationSinWave = rotationSinWave + 0.1\n\t\n\t-- Calculate the size offset\n\tlocal sizeOffset = math.sin(fontSizeSinWave) * 7.5\n\tfontSizeSinWave = fontSizeSinWave + 0.2\n\n\t-- Get the size of the text we are going to render.\n\tlocal textWidth, textHeight = display.calcASCFTextSize(fontName, text, fontSize + sizeOffset, 0)\n\t\n\t-- Increase gradientindex by 1 and revert back to 1 if it overflows.\n\tgradientIndex = gradientIndex + 1\n\tif gradientIndex > #gradient then\n\t\tgradientIndex = 1\n\tend\n\t\n\t-- Get the color\n\tlocal color = gradient[gradientIndex]\n\t\n\t-- Clear the display\n\tdisplay.clear(\"0A0A0A\")\n\n\t-- Draw it\n\tdisplay.drawASCFText((displayWidth / 2) - (textWidth / 2), (displayHeight / 2) - (textHeight / 2), text, fontName, color, rotation, fontSize + sizeOffset)\n\n\t-- Update it\n\tdisplay.update()\nend\n\nfunction onDestroy()\n\t-- Clear & update.\n\tdisplay.clear()\n\tdisplay.update()\nend\n\n-- Please scroll up to see configs! --"
    },
    
    /* GRAVITY CONTROLLER */
    {
        "name": "Gravity Controller Example",
        "script": "local gravityController = sc.getGravityControllers()[1]\nlocal multiplier = 0 -- Setting it to 0 makes it no gravity! 2 for double the gravitiy.\n\nfunction onLoad()\n\tgravityController.setGravityEnabled(true)\n\tgravityController.setMultiplier(0)\nend\n\nfunction onDestroy()\n\tgravityController.setGravityEnabled(false)\nend"
    },

    /* GAMES */
    {
        "name": "PONG! Game",
        "script": "-- This is the game PONG, For the bare mininum, connect a display to the computer\n-- A 128x128 display is recommended.\n--\n-- Additional components you could connect:\n--\t  Speaker: Connecting a speaker adds sound effects to the game.\n--\t  Input registers: (Connect any of these input registers to the computer with 1 of the name's bellow will add functionaility)\n--\t\t  \"reset\": Lets you reset the game\n--\t\t  \"aiMode\": Lets you toggle a gamemode where its AI vs AI.\n--\t\t  \"debugMode\": If enabled, it shows the ball's direction & 2 lines on the player pad to give you information if the ball's y cordinates fits in your pad.\n\n-- SOURCE CODE --\n\nlocal display = sc.getDisplays()[1]\nlocal speaker = sc.getSpeakers()[1]\n\nif not display then\n\terror(\"Please connect a display!\")\nend\n\nlocal gameState = 0\nlocal playerY = 75\nlocal aiY = 75\nlocal speed = 0.5\nlocal aiSpeed1 = 0.2\nlocal aiErrorMargin1 = 3\nlocal aiSpeed2 = 0.2\nlocal aiErrorMargin2 = 3\nlocal padHeight = 16\nlocal screenHeight, screenWidth = display.getDimensions()\nlocal ballX = screenWidth / 2\nlocal ballY = screenHeight / 2\nlocal ballSpeedX = 1.25\nlocal ballSpeedY = 1.25\nlocal ballRadius = 2\nlocal playerScore = 0\nlocal aiScore = 0\nlocal maxScore = 10\nlocal maxBounceAngle = math.rad(85)\nlocal clock = 0\n\nlocal currentisAIvsAIMode = false\n\nlocal minBallSpeed = 0.75\n\nif not speaker then\n\tspeaker = {beep = function() end, longBeep = function() end}\nend\n\nfunction getRegValue(name, defaultValue)\n\tlocal success, result = pcall(sc.getReg, name)\n\tif not success then\n\t\treturn defaultValue\n\tend\n\n\treturn result\nend\n\nfunction enforceMinimumBallSpeed()\n\tlocal ballSpeed = math.sqrt(ballSpeedX^2 + ballSpeedY^2)\n\tif ballSpeed < minBallSpeed then\n\t\tlocal scale = minBallSpeed / ballSpeed\n\t\tballSpeedX = ballSpeedX * scale\n\t\tballSpeedY = ballSpeedY * scale\n\tend\nend\n\nfunction reSkillAIs()\n\taiSpeed1 = 0.15 + math.random() * 0.2\n\taiSpeed2 = 0.15 + math.random() * 0.2\n\taiErrorMargin1 = 2 + math.random() * 3\n\taiErrorMargin2 = 2 + math.random() * 3\n\tspeed = 0.1 + math.random()\nend\n\nfunction resetBall()\n\tballX = screenWidth / 2\n\tballY = screenHeight / 2\n\tballSpeedX = 1.25 * ((math.random() > 0.5) and 1 or -1)\n\tballSpeedY = 1.25 * ((math.random() > 0.5) and 1 or -1)\nend\n\nfunction checkGameOver()\n\tif currentisAIvsAIMode then\n\t\tif playerScore >= maxScore then return \"AI #1 Wins!\" elseif aiScore >= maxScore then return \"AI #2 Wins!\" end\n\t\treturn\n\tend\n\tif playerScore >= maxScore then return \"Player Wins!\" elseif aiScore >= maxScore then return \"AI Wins!\" end\nend\n\nfunction modifyBounceAngle(paddleY, ballY, padHeight)\n\tlocal relativeIntersectY = (ballY - paddleY) / (padHeight / 2)\n\tlocal bounceAngle = relativeIntersectY * maxBounceAngle\n\treturn bounceAngle\nend\n\nfunction updateBallDirectionAfterPaddleHit(paddleY, ballY, padHeight)\n\tlocal bounceAngle = modifyBounceAngle(paddleY, ballY, padHeight)\n\tlocal ballSpeed = math.sqrt(ballSpeedX^2 + ballSpeedY^2)\n\tballSpeedX = ballSpeed * math.cos(bounceAngle)\n\tballSpeedY = ballSpeed * math.sin(bounceAngle)\n\n\tspeaker.beep()\nend\n\nfunction onLoad()\n\tdisplay.enableTouchScreen(true)\n\tresetBall()\nend\n\nfunction onUpdate()\n\tdebugMode = getRegValue(\"debugMode\", 0) == 1\n\n\tif getRegValue(\"reset\", 0) == 1 then\n\t\tplayerScore = 0\n\t\taiScore = 0\n\t\taiY = 75\n\t\tplayerY = 75\n\t\tresetBall()\n\t\tgameState = 0\n\t\tclock = 0\n\t\treturn\n\tend\n\n\tif gameState == 0 then\n\t\tlocal width, height = display.calcTextSize(\"Touch to play!\")\n\t\tdisplay.clear()\n\t\tdisplay.drawText((screenWidth / 2) - (width / 2), (screenHeight / 2) - (height / 2), \"Touch to play!\")\n\t\t\n\t\tif getRegValue(\"aiMode\", 0) == 1 then\n\t\t\tdisplay.drawText(4, 4, \"AI vs AI Mode\", \"00ee00\")\n\t\tend\n\t\t\n\t\tdisplay.update()\n\t\tlocal touchData = display.getTouchData()\n\t\tif touchData then\n\t\t\tgameState = 1\n\t\t\tplayerY = touchData.y\n\n\t\t\tplayerScore = 0\n\t\t\taiScore = 0\n\t\t\taiY = 75\n\t\t\tplayerY = 75\n\n\t\t\tcurrentisAIvsAIMode = getRegValue(\"aiMode\", 0) == 1\n\t\t\tspeed = 0.5\n\t\t\tballSpeedX = currentisAIvsAIMode and 1.25 or 1\n\t\t\tballSpeedY = currentisAIvsAIMode and 1.25 or 1\n\t\t\t\n\t\t\tif currentisAIvsAIMode then\n\t\t\t\treSkillAIs()\n\t\t\telse\n\t\t\t\taiSpeed1 = 0.2\n\t\t\tend\n\t\tend\n\telseif gameState == 1 then\n\t\tlocal touchData = display.getTouchData()\n\n\t\tif not currentisAIvsAIMode and touchData then\n\t\t\tlocal newY = sm.util.clamp(touchData.y, padHeight / 2, screenHeight - padHeight / 2)\n\t\t\tplayerY = playerY + (newY - playerY) * speed\n\t\tend\n\n\t\tif currentisAIvsAIMode then\n\t\t\tlocal targetPlayerY = ballY + aiErrorMargin2 * (math.random() - 0.5)\n\t\t\tplayerY = playerY + (targetPlayerY - playerY) * aiSpeed2\n\t\t\tplayerY = sm.util.clamp(playerY, padHeight / 2, screenHeight - padHeight / 2)\n\n\t\t\tlocal targetAiY = ballY + aiErrorMargin1 * (math.random() - 0.5)\n\t\t\taiY = aiY + (targetAiY - aiY) * aiSpeed1\n\t\t\taiY = sm.util.clamp(aiY, padHeight / 2, screenHeight - padHeight / 2)\n\t\telse\n\t\t\tlocal targetAiY = ballY + aiErrorMargin1 * (math.random() - 0.5)\n\t\t\taiY = aiY + (targetAiY - aiY) * aiSpeed1\n\t\t\taiY = sm.util.clamp(aiY, padHeight / 2, screenHeight - padHeight / 2)\n\t\tend\n\n\t\tballX = ballX + ballSpeedX\n\t\tballY = ballY + ballSpeedY\n\t\t\n\t\tif ballY - ballRadius < 0 then\n\t\t\tballY = ballRadius\n\t\t\tballSpeedY = -ballSpeedY\n\t\t\t\n\t\t\tif currentisAIvsAIMode then\n\t\t\t\tballSpeedY = ballSpeedY + ((0.85 - math.random()) * 2)\n\t\t\telse\n\t\t\t\tballSpeedX = ballSpeedX * 1.05\n\t\t\t\tballSpeedY = ballSpeedY * 1.05\n\t\t\tend\n\n\t\t\tenforceMinimumBallSpeed()\n\t\t\tspeaker.beep()\n\t\telseif ballY + ballRadius > screenHeight then\n\t\t\tballY = screenHeight - ballRadius\n\t\t\tballSpeedY = -ballSpeedY\n\n\t\t\tif currentisAIvsAIMode then\n\t\t\t\tballSpeedY = ballSpeedY + ((0.85 - math.random()) * 2)\n\t\t\telse\n\t\t\t\tballSpeedX = ballSpeedX * 1.05\n\t\t\t\tballSpeedY = ballSpeedY * 1.05\n\t\t\tend\n\n\t\t\tenforceMinimumBallSpeed()\n\t\t\tspeaker.beep()\n\t\tend\n\n\t\tlocal playerPaddleLeft = 10\n\t\tlocal playerPaddleRight = playerPaddleLeft + 4\n\t\tlocal playerPaddleTop = playerY - padHeight / 2\n\t\tlocal playerPaddleBottom = playerY + padHeight / 2\n\n\t\tlocal aiPaddleLeft = screenWidth - 14\n\t\tlocal aiPaddleRight = aiPaddleLeft + 4\n\t\tlocal aiPaddleTop = aiY - padHeight / 2\n\t\tlocal aiPaddleBottom = aiY + padHeight / 2\n\t\t\n\t\tlocal ballLeft = ballX - ballRadius\n\t\tlocal ballRight = ballX + ballRadius\n\t\tlocal ballTop = ballY - ballRadius\n\t\tlocal ballBottom = ballY + ballRadius\n\n\t\tif ballRight > playerPaddleLeft and ballLeft < playerPaddleRight and ballBottom > playerPaddleTop and ballTop < playerPaddleBottom then\n\t\t\tupdateBallDirectionAfterPaddleHit(playerY, ballY, padHeight)\n\t\t\tballSpeedX = math.abs(ballSpeedX)\n\n\t\t\tif not currentisAIvsAIMode then\n\t\t\t\tballSpeedX = ballSpeedX * 1.05\n\t\t\t\tballSpeedY = ballSpeedY * 1.05\n\t\t\tend\n\n\t\t\tenforceMinimumBallSpeed()\n\t\tend\n\t\t\n\t\tif ballLeft < aiPaddleRight and ballRight > aiPaddleLeft and ballBottom > aiPaddleTop and ballTop < aiPaddleBottom then\n\t\t\tupdateBallDirectionAfterPaddleHit(aiY, ballY, padHeight)\n\t\t\tballSpeedX = -math.abs(ballSpeedX)\n\n\t\t\tif not currentisAIvsAIMode then\n\t\t\t\tballSpeedX = ballSpeedX * 1.05\n\t\t\t\tballSpeedY = ballSpeedY * 1.05\n\t\t\tend\n\n\t\t\tenforceMinimumBallSpeed()\n\t\tend\n\t\t\n\t\tif ballLeft < 0 then\n\t\t\taiScore = aiScore + 1\n\t\t\tresetBall()\n\t\t\tspeaker.longBeep()\n\t\telseif ballRight > screenWidth then\n\t\t\tplayerScore = playerScore + 1\n\t\t\tresetBall()\n\t\t\tspeaker.longBeep()\n\t\tend\n\n\t\tlocal gameOverMessage = checkGameOver()\n\t\tif gameOverMessage then\n\t\t\tgameState = 2\n\t\tend\n\n\t\tdisplay.clear()\n\t\tif debugMode then\n\t\t\tdisplay.drawLine(1, playerY + (padHeight / 2), screenWidth, playerY + (padHeight / 2), \"888888\")\n\t\t\tdisplay.drawLine(1, playerY - (padHeight / 2), screenWidth, playerY - (padHeight / 2), \"888888\")\n\t\tend\n\t\tdisplay.drawFilledRect(10, playerY - padHeight / 2, 4, padHeight, \"eeeeee\")\n\t\tdisplay.drawFilledRect(screenWidth - 14, aiY - padHeight / 2, 4, padHeight, \"eeeeee\")\n\n\t\tfor i = 1, screenHeight, 1 do\n\t\t\tif i % 2 == 0 then\n\t\t\t\tdisplay.drawPixel(screenWidth / 2, i, \"eeeeee\")\n\t\t\tend\n\t\tend\n\n\t\tif debugMode then\n\t\t\tlocal lineEndX = ballX\n\t\t\tlocal lineEndY = ballY\n\t\t\n\t\t\tif ballSpeedX < 0 then\n\t\t\t\tlocal timeToPaddle = (10 - (ballX - ballRadius)) / ballSpeedX\n\t\t\t\tlineEndX = 10\n\t\t\t\tlineEndY = ballY + ballSpeedY * timeToPaddle\n\t\t\n\t\t\telseif ballSpeedX > 0 then\n\t\t\t\tlocal timeToPaddle = (screenWidth - 14 - (ballX + ballRadius)) / ballSpeedX\n\t\t\t\tlineEndX = screenWidth - 14\n\t\t\t\tlineEndY = ballY + ballSpeedY * timeToPaddle\n\t\t\tend\n\t\t\n\t\t\tdisplay.drawLine(ballX, ballY, lineEndX, lineEndY, \"eeee00\")\n\t\tend\n\n\t\tdisplay.drawFilledRect(ballX - ballRadius, ballY - ballRadius, ballRadius * 2, ballRadius * 2, \"ee0000\")\n\t\tdisplay.drawText(10, 5, tostring(playerScore))\n\t\tdisplay.drawText(screenWidth - 14, 5, tostring(aiScore))\n\n\t\tdisplay.update()\n\telseif gameState == 2 then\n\t\tlocal gameOverMessage = checkGameOver()\n\t\tlocal width, height = display.calcTextSize(gameOverMessage)\n\t\tdisplay.clear()\n\t\tdisplay.drawText((screenWidth / 2) - (width / 2), (screenHeight / 2) - (height / 2), gameOverMessage)\n\t\tdisplay.update()\n\t\t\n\t\tclock = clock + 1\n\t\tif clock == 5 * 50 then\n\t\t\tclock = 0\n\t\t\tgameState = 0\n\t\tend\n\tend\nend\n\n-- Please scroll to the top for information!"
    },

    /* OTHER */
    {
        "name": "Whiteboard Example (Multidisplay)",
        "script": "local display = sc.multidisplay.new(sc.getDisplays(), 3, 2)\nlocal prevTouchTable = nil\nlocal usernameToColor = {}\n\nfunction onLoad()\n\tdisplay.clear()\n\tdisplay.update()\n\tdisplay.enableTouchScreen(true)\nend\n\nfunction onUpdate()\n\tlocal touchTable = display.getTouchTable()\n\n\tif sc.getReg(\"clear\") == 1 then\n\t\tdisplay.clear()\n\t\tdisplay.update()\n\tend\n\n\tif next(touchTable) ~= nil then\n\t\tfor username, data in pairs(touchTable) do\n\t\t\tusernameToColor[username] = usernameToColor[username] or sc.color.random0to1()\n\n\t\t\tif prevTouchTable and prevTouchTable[username] then\n\t\t\t\tlocal prevTouchData = prevTouchTable[username]\n\n\t\t\t\tdisplay.drawLine(data.x, data.y, prevTouchData.x, prevTouchData.y, usernameToColor[username])\n\t\t\telse\n\t\t\t\tdisplay.drawPixel(data.x, data.y, usernameToColor[username])\n\t\t\tend\n\t\tend\n\n\t\tprevTouchTable = touchTable\n\t\tdisplay.update()\n\telse\n\t\tprevTouchTable = nil\n\tend\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend\n\n-- Connect a input register called \"clear\" & a button should be connected to it. Its so you can\n-- clear the whiteboard!\n\n-- NOTE: Expects a 2x3 display grid in this format. Left top right, Top to bottom."
    }
]