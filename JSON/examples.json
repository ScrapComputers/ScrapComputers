[
    {
        "name": "Computer Script Template",
        "script": "-- Any variables outside the main functions are global!\n\n-- Gets called when the computer starts up.\nfunction onLoad()\nend\n\n-- Gets called every tick.\nfunction onUpdate( deltaTime )\nend\n\n-- Gets called when the computer errors out.\nfunction onError( errMsg )\nend\n\n-- Gets called when the computers code is saved.\nfunction onReload()\nend\n\n-- Gets called when the computer looses power.\nfunction onPowerLoss()\nend\n\n-- Gets called when the computer shuts down.\nfunction onDestroy()\nend"
    },
    {
        "name": "Base64 Encoding & Decoding",
        "script": "local message = \"Hello World!\"\n\nfunction onLoad()\n\tprint(\"Message: \" .. message)\n\n\tlocal encodedMessage = sc.base64.encode(message)\n\tprint(\"Encoded: \" .. encodedMessage)\n\n\tlocal decodedMessage = sc.base64.decode(encodedMessage)\n\tprint(\"Decoded: \" .. decodedMessage)\nend"
    },
    {
        "name": "MD5 Hashing",
        "script": "local message = \"Hello world!\"\n\nfunction onLoad()\n\tprint(\"Message: \" .. message)\n\tprint(\"MD5 Encoded: \" .. sc.md5.sumhexa(message))\nend"
    },
    {
        "name": "SHA256 Hashing",
        "script": "local message = \"Hello world!\"\n\nfunction onLoad()\n\tprint(\"Message: \" .. message)\n\tprint(\"SHA256 Encoded: \" .. sc.sha256.encode(message))\nend"
    },
    {
        "name": "Terminal - Echo",
        "script": "local terminal = sc.getTerminals()[1]\nassert(terminal, \"Terminal not found! Make sure you have connected a Terminal to the computer!\")\n\nfunction onLoad()\n\tterminal.clear()\n\tterminal.send(\"#3A96DDComputer: Send a input and il echo it back to you!\")\nend\n\nfunction onUpdate()\n\tif terminal.receivedInputs() then\n\t\tlocal text = terminal.getInput()\n\t\tterminal.send(\"> \" .. text)\n\tend\nend\n\nfunction onDestroy()\n\tterminal.clear()\n\tterminal.clearInputHistory()\nend"
    },
    {
        "name": "Drive - Writing",
        "script": "local drive = sc.getDrives()[1]\nassert(drive, \"Drive not found! Make sure you have connected a Drive to the computer!\")\n\nlocal data = {\n\thello = \"world!\"\n}\n\nfunction onLoad()\n\tdrive.save(data)\n\n\tprint(\"Saved contents to the drive!\")\nend"
    },
    {
        "name": "Drive - Reading",
        "script": "local drive = sc.getDrives()[1]\nassert(drive, \"Drive not found! Make sure you have connected a Drive to the computer!\")\n\nfunction onLoad()\n\tprint(drive.load())\nend"
    },
    {
        "name": "Hologram - Cube",
        "script": "local hologram = sc.getHolograms()[1]\nassert(hologram, \"Hologram not found! Make sure you have connected a Hologram to the computer!\")\n\nlocal scale = sm.vec3.new(1, 1, 1)\nlocal position = sm.vec3.new(0, 1, 0)\nlocal rotation = sm.vec3.new(45, 25, 15)\nlocal color = sc.color.random0to1()\n\nlocal id = -1\n\nfunction onLoad()\n\tid = hologram.createCube(position, rotation, scale, color)\nend\n\nfunction onUpdate()\n\tlocal object = hologram.getObject(id)\n\tobject.setRotation(rotation)\n\n\trotation = rotation + sm.vec3.one()\nend\n\nfunction onDestroy()\n\tlocal object = hologram.getObject(id)\n\tobject.delete()\nend"
    },
    {
        "name": "Hologram - Custom",
        "script": "local hologram = sc.getHolograms()[1]\nassert(hologram, \"Hologram not found! Make sure you have connected a Hologram to the computer!\")\n\nlocal uuid = sm.uuid.new(\"6ad29c0e-8209-4dca-9133-20d7a2fc2d63\")\nlocal scale = sm.vec3.new(1, 1, 1)\nlocal position = sm.vec3.new(0, 1, 0)\nlocal rotation = sm.vec3.new(45, 25, 15)\nlocal color = sm.color.new(\"4A4A4A\")\n\nlocal id = -1\n\nfunction onLoad()\n\tid = hologram.createCustomObject(uuid, position, rotation, scale, color)\nend\n\nfunction onDestroy()\n\tlocal object = hologram.getObject(id)\n\tobject:delete()\nend"
    },
    {
        "name": "Hologram - Atom",
        "script": "local hologram = sc.getHolograms()[1]\nassert(hologram, \"Hologram not found! Make sure you have connected a Hologram to the computer!\")\n\nlocal protonColor = sm.color.new(\"ff0000\")\nlocal neutronColor = sm.color.new(\"00ff00\")\nlocal electronColor = sm.color.new(\"ffffff\")\nlocal datumPosition = sm.vec3.new(0, 1, 0)\n\nlocal nucleusObjects = {}\nlocal electronObjects = {}\n\n-- Get the ammount of protons and neutrons in the nucleus\nlocal nucleusCount = math.random(2, 5)\nlocal electronCount = math.random(1, 3)\n\n-- Create average position used for centering the rotation of the electrons\nlocal averagePosition = sm.vec3.zero()\n\n-- Generates a random rotation direction for electrons\nlocal function generateRandom()\n\tif math.random(0, 1) == 1 then\n\t\treturn sm.vec3.new(0, math.rad(10), 0)\n\tend\n\n\treturn sm.vec3.new(0, math.rad(-10), 0)\nend\n\nfunction onLoad()\n\t-- Loop for every nucleus object\n\tfor i = 1, nucleusCount do\n\t\t-- Generates a random bool to make the object a proton and generates a random offset position\n\t\tlocal isProton = math.random(0, 1) == 1\n\t\tlocal randOffset = sm.vec3.new(math.random(), math.random(), math.random())\n\t\n\t\t-- Set the objects parameters\n\t\tlocal position = datumPosition + randOffset - randOffset / 2\n\t\tlocal rotation = sm.vec3.zero()\n\t\tlocal scale = sm.vec3.one()\n\t\tlocal color = isProton and protonColor or neutronColor\n\n\t\t-- Create the object and add it to its respective table, along with data needed for modifications\n\t\tnucleusObjects[#nucleusObjects + 1] = {\n\t\t\tid = hologram.createSphere(position, rotation, scale, color),\n\t\t\tposition = position\n\t\t}\n\n\t\t-- Update the average position with the random offset\n\t\taveragePosition = averagePosition + position\n\tend\n\n\t-- Complete the average\n\taveragePosition = averagePosition / nucleusCount\n\n\t-- Loop for every electron object\n\tfor i = 1, electronCount do\n\t\t-- Set the objects parameters\n\t\tlocal position = sm.vec3.new(i + 0.5, 0, 0) + averagePosition\n\t\tlocal rotation = sm.vec3.zero()\n\t\tlocal scale = sm.vec3.one() / 10\n\t\n\t\t-- Create the object and add it to its respective table, along with data needed for modifications\n\t\telectronObjects[#electronObjects + 1] = {\n\t\t\tid = hologram.createSphere(position, rotation, scale, electronColor),\n\t\t\tposition = position,\n\t\t\torbitDirection = generateRandom() -- dictates the direction of rotation\n\t\t}\n\tend\nend\n\nfunction onUpdate()\n\t-- Loop through every nucleus object\n\tfor i, objectData in pairs(nucleusObjects) do\n\t\t-- Get the object and create a noise offset for vibration\n\t\tlocal object = hologram.getObject(objectData.id)\n\t\tlocal noiseOffset = sm.vec3.new(math.random() / 10, math.random() / 10, math.random() / 10)\n\n\t\t-- Set the new position\n\t\tobject.setPosition(objectData.position + noiseOffset - noiseOffset / 2)\n\tend\n\n\t-- Loop through every electron object\n\tfor i, objectData in pairs(electronObjects) do\n\t\tlocal object = hologram.getObject(objectData.id)\n\n\t\t-- Get the direction from the current position to the average position and rotate based on the orbit direction\n\t\tlocal direction = averagePosition - objectData.position\n\t\tlocal newDirection = direction:rotateY(objectData.orbitDirection.y)\n\n\t\t-- Create the new electron position with the new direction\n\t\tlocal newPosition = averagePosition - newDirection\n\n\t\t-- Update the objects position and update the tables saved position\n\t\tobject.setPosition(newPosition)\n\t\tobjectData.position = newPosition\n\tend\nend"
    },
    {
        "name": "Radar - Object Range Detection",
        "script": "local radar = sc.getRadars()[1]\nassert(radar, \"Radar not found! Make sure you have connected a Radar to the computer!\")\n\nlocal vAngle = 35 -- The vertical angle\nlocal hAngle = 35 -- The horizontal angle\n\nfunction onLoad()\n\tradar.setVerticalScanAngle(vAngle)\n\tradar.setHorizontalScanAngle(hAngle)\nend\n\nfunction onUpdate()\n\tlocal targets = radar.getTargets()\n\tprint(\"Total Targets: \" .. tostring(#targets))\n\t\n\tfor _, target in pairs(targets) do\n\t\tlocal roundedPosition = sm.vec3.new(\n\t\t\tmath.floor(target.position.x),\n\t\t\tmath.floor(target.position.y),\n\t\t\tmath.floor(target.position.z)\n\t\t)\n\n\t\tprint(tostring(roundedPosition) .. \" | \" .. tostring(target.surfaceArea))\n\tend\nend"
    },
    {
        "name": "NetworkPort - Sending Packets",
        "script": "local networkPort = sc.getNetworkPorts()[1]\nassert(networkPort, \"Network Port not found! Make sure you have connected a Network Port to the computer!\")\n\nfunction onLoad()\n\tif not networkPort.hasConnection() then\n\t\tprint(\"No connection found!\")\n\t\treturn\n\tend\n\n\tnetworkPort.sendPacket(\"Hello World!\")\n\tprint(\"Sent packet!\")\nend"
    },
    {
        "name": "NetworkPort - Receiving Packets",
        "script": "local networkPort = sc.getNetworkPorts()[1]\nassert(networkPort, \"Network Port not found! Make sure you have connected a Network Port to the computer!\")\n\nfunction onLoad()\n\tif not networkPort.hasConnection() then\n\t\tprint(\"No connection found!\")\n\t\treturn\n\tend\n\n\tif networkPort.getTotalPackets() > 0 then\n\t\tlocal packet = networkPort.receivePacket()\n\t\tprint(\"Received \" .. tostring(packet))\n\telse\n\t\tprint(\"No packets received!\")\n\tend\nend"
    },
    {
        "name": "Display - Black & White Video",
        "script": "-- Config --\n\n-- Tick this when using a custom video. This just enforces 64x64 display resolution only.\nlocal ignoreDimensionAsserts = false\n\n-- File path to video here, check out DisplayVideos folder!\nlocal videoData = sm.json.open(\"$CONTENT_DATA/DisplayVideos/BadApple64x64_BW.json\")\n\n-- The frame rate the videoData is at.\nlocal fps = 30\n\n-- Source Code --\n\nlocal math_floor = math.floor\n\nlocal display = sc.getDisplays()[1]\nassert(display, \"Display not found! Make sure you have connected a Display to the computer!\")\n\nlocal width, height = display.getDimensions()\nif not ignoreDimensionAsserts then\n\tassert(width == 64 and height == 64, \"Invalid Display Resolution! Expected 64x64 for Bad Apple Black & White!\")\nend\n\nlocal frameCount = 0\nlocal frameIncrementAmount = fps / 40\nlocal pixelCounter = 1\n\nlocal whiteColor = sm.color.new(1, 1, 1)\n\n-- Turns a coordinate number that is stored in the json into x and y\nfunction indexToCoordinate(index, width)\n\treturn (index - 1) % width + 1, math_floor((index - 1) / width) + 1\nend\n\n-- Renders a frame by parsing video data structure\nfunction renderFrame()\n\tlocal drawFilledRect = display.drawFilledRect\n\n\tlocal length = videoData[pixelCounter]\n\tif not length then\n\t\tpixelCounter = 1\n\t\tlength = videoData[pixelCounter]\n\tend\n\n\tpixelCounter = pixelCounter + 1\n\n\tif length == 0 then return end\n\n\tfor _ = 1, length do\n\t\tlocal x, y = indexToCoordinate(videoData[pixelCounter], width)\n\t\tpixelCounter = pixelCounter + 1\n\n\t\tlocal sx, sy = indexToCoordinate(videoData[pixelCounter], width)\n\t\tpixelCounter = pixelCounter + 1\n\n\t\tdrawFilledRect(x, y, sx, sy, whiteColor)\n\tend\nend\n\nfunction onUpdate()\n\t-- Times the update according with the fps specified\n\tif math_floor(frameCount) ~= math_floor(frameCount - frameIncrementAmount) then\n\t\tdisplay.clear()\n\t\trenderFrame()\n\t\tdisplay.update()\n\tend\n\n\tframeCount = frameCount + frameIncrementAmount\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend\n\n-- Scroll up to put ur Video Data & Video FPS inside!"
    },
    {
        "name": "Display - Color Video",
        "script": "-- Config --\n\n-- Tick this when using a custom video. This just enforces 64x64 display resolution only.\nlocal ignoreDimensionAsserts = false\n\n-- File path to video here, check out DisplayVideos folder!\nlocal videoData = sm.json.open(\"$CONTENT_DATA/DisplayVideos/BadApple64x64_Color.json\")\n\n-- The frame rate the videoData is at.\nlocal fps = 30\n\n-- Source Code --\n\nlocal math_floor = math.floor\n\nlocal display = sc.getDisplays()[1]\nassert(display, \"Display not found! Make sure you have connected a Display to the computer!\")\n\nlocal width, height = display.getDimensions()\nif not ignoreDimensionAsserts then\n\tassert(width == 64 and height == 64, \"Invalid Display Resolution! Expected 64x64 for Bad Apple Black & White!\")\nend\n\nlocal frameCount = 0\nlocal frameIncrementAmount = fps / 40\nlocal pixelCounter = 1\n\n-- Turns a coordinate number that is stored in the json into x and y\nfunction indexToCoordinate(index, width)\n\treturn (index - 1) % width + 1, math_floor((index - 1) / width) + 1\nend\n\n-- Renders a frame by parsing video data structure\nfunction renderFrame()\n\tlocal drawFilledRect = display.drawFilledRect\n\n\tlocal length = videoData[pixelCounter]\n\tif not length then\n\t\tpixelCounter = 1\n\t\tlength = videoData[pixelCounter]\n\tend\n\n\tpixelCounter = pixelCounter + 1\n\n\tif length == 0 then return end\n\n\tfor _ = 1, length do\n\t\tlocal x, y = indexToCoordinate(videoData[pixelCounter], width)\n\t\tpixelCounter = pixelCounter + 1\n\n\t\tlocal sx, sy = indexToCoordinate(videoData[pixelCounter], width)\n\t\tpixelCounter = pixelCounter + 1\n\n\t\tdrawFilledRect(x, y, sx, sy, videoData[pixelCounter])\n\t\tpixelCounter = pixelCounter + 1\n\tend\nend\n\nfunction onUpdate()\n\t-- Times the update according with the fps specified\n\tif math_floor(frameCount) ~= math_floor(frameCount - frameIncrementAmount) then\n\t\tdisplay.clear()\n\t\trenderFrame()\n\t\tdisplay.update()\n\tend\n\n\tframeCount = frameCount + frameIncrementAmount\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend\n\n-- Scroll up to put ur Video Data & Video FPS inside!"
    },
    {
        "name": "Display - Image Rendering",
        "script": "-- The example image used is 256x256, please use a 256x256 display!\n\nlocal display = sc.getDisplays()[1]\nassert(display, \"Display not found! Make sure you have connected a Display to the computer!\")\n\nlocal width, height = display.getDimensions()\nassert(width == 256 and height == 256, \"Invalid Display Resolution! Please use a 256x256 display for this example\")\n\nfunction onLoad()\n\tdisplay.setOptimizationThreshold(0.02)\n\tdisplay.loadImage(width, height, \"example.json\")\n\tdisplay.update()\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    {
        "name": "Display - Mandelbrot Fractal",
        "script": "local display = sc.getDisplays()[1]\nassert(display, \"Display not found! Make sure you have connected a Display to the computer!\")\n\nlocal width, height = display.getDimensions()\n\n--[[\n\tSome recommended values to try:\n\n\tmaxIterations = 1000\n\tzoom = 20000\n\toffsetX = -0.7497\n\toffsetY = 0.0315\n]]\n\nlocal maxIterations = 200 -- Maximum iterations per pixel, determines the detail and accuracy of the fractal\nlocal zoom = 1 -- Zoom multiplier, adjusts the scale of the fractal\nlocal offsetX = 0 -- X-axis offset for the fractal's center\nlocal offsetY = 0 -- Y-axis offset for the fractal's center\n\nlocal blackColor = sm.color.new(0, 0, 0)\n\n-- Function to draw a Mandelbrot fractal on the display\nfunction onLoad()\n\tlocal pixelTbl = {}\n\tlocal pixelTblIndex = 1\n\n\tfor x = 1, width do\n\t\tfor y = 1, height do\n\t\t\t-- Convert pixel coordinates (x, y) to complex plane coordinates (zx, zy)\n\t\t\tlocal zx, zy = (x - width / 2) / (0.5 * zoom * width) + offsetX, (y - height / 2) / (0.5 * zoom * height) + offsetY\n\t\t\tlocal cRe, cIm = zx, zy  -- The real and imaginary parts of the initial complex number\n\t\t\tlocal iteration = 0  -- Iteration counter\n\n\t\t\t-- Iterate to determine if the point belongs to the Mandelbrot set\n\t\t\twhile (zx * zx + zy * zy < 4) and (iteration < maxIterations) do\n\t\t\t\tlocal newZx = zx * zx - zy * zy + cRe  -- Calculate the new real part\n\t\t\t\tlocal newZy = 2 * zx * zy + cIm  -- Calculate the new imaginary part\n\t\t\t\tzx, zy = newZx, newZy  -- Update zx and zy for the next iteration\n\t\t\t\titeration = iteration + 1  -- Increment the iteration counter\n\t\t\tend\n\n\t\t\t-- Determine the color based on the number of iterations\n\t\t\tlocal brightness = iteration / maxIterations\n\t\t\tlocal color = blackColor\n\n\t\t\t-- If the point isn't in the set (reached max iterations), map the iteration count to a grayscale brightness\n\t\t\tif iteration ~= maxIterations then\n\t\t\t\tcolor = sm.color.new(brightness, brightness, brightness) * 2  -- Adjust brightness level as needed\n\t\t\tend\n\n\t\t\t-- Add the pixel data to the pixel table\n\t\t\tpixelTbl[pixelTblIndex] = {x = x, y = y, scale = {x = 1, y = 1}, color = color}\n\t\t\tpixelTblIndex = pixelTblIndex + 1\n\t\tend\n\tend\n\t\n\tdisplay.drawFromTable(pixelTbl)\n\tdisplay.update()\nend"
    },
    {
        "name": "Display - Noise Generator",
        "script": "local display = sc.getDisplays()[1]\nassert(display, \"Display not found! Make sure you have connected a Display to the computer!\")\n\nlocal width, height = display.getDimensions()\n\nlocal function generateSeed()\n\tlocal seed = 2\n\tfor _ = 1, 10 do\n\t\tseed = seed * math.random(2, 100)\n\tend\n\n\treturn seed\nend\n\nfunction onLoad()\n\tlocal seed = generateSeed()\n\tfor x = 1, width, 1 do\n\t\tfor y = 1, height, 1 do\n\t\t\tdisplay.drawPixel(x, y, sc.color.newSingular(sm.noise.octaveNoise2d(x, y, 7.5, seed)))\n\t\tend\n\tend\n\tdisplay.update()\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    {
        "name": "Display - Optimization Tester",
        "script": "-- WARNING: This can get very laggy on high pixel count displays, do this at your own risk\n\nlocal display = sc.getDisplays()[1]\nassert(display, \"Display not found! Make sure you have connected a Display to the computer!\")\n\nlocal width, height = display.getDimensions()\n\nfunction onLoad()\n\tfor x = 1, width do\n\t\tfor y = 1, height do\n\t\t\tdisplay.drawPixel(x, y, sc.color.random0to1())\n\t\tend\n\tend\n\t\n\tdisplay.update()\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    {
        "name": "Display - Rotating Cube",
        "script": "local display = sc.getDisplays()[1]\nassert(display, \"Display not found! Make sure you have connected a Display to the computer!\")\n\nlocal width, height = display.getDimensions()\n\nlocal cubeSize = math.min(width, height) / 2  -- Scale of the cube size\nlocal angleX, angleY = 0, 0  -- Initial angles for rotation\nlocal centerX, centerY = width / 2, height / 2  -- Center of the display\nlocal rotationSpeed = 0.02  -- Speed of rotation\nlocal color = sc.color.random0to1()\n\nlocal vertices = {\n\tsm.vec3.new(-1, -1, -1),\n\tsm.vec3.new(1, -1, -1),\n\tsm.vec3.new(1, 1, -1),\n\tsm.vec3.new(-1, 1, -1),\n\tsm.vec3.new(-1, -1, 1),\n\tsm.vec3.new(1, -1, 1),\n\tsm.vec3.new(1, 1, 1),\n\tsm.vec3.new(-1, 1, 1)\n}\n\nlocal edges = {\n\t{1, 2}, {2, 3}, {3, 4}, {4, 1},  -- Edges of the front face\n\t{5, 6}, {6, 7}, {7, 8}, {8, 5},  -- Edges of the back face\n\t{1, 5}, {2, 6}, {3, 7}, {4, 8}   -- Connecting edges between front and back faces\n}\n\nfunction projectVertex(vertex)\n\tlocal scale = cubeSize / (vertex.z + 3)\n\tlocal x = vertex.x * scale + centerX\n\tlocal y = vertex.y * scale + centerY\n\n\tx = sm.util.clamp(math.floor(x + 0.5), 1, width)\n\ty = sm.util.clamp(math.floor(y + 0.5), 1, height)\n\n\treturn x, y\nend\n\nfunction onUpdate()\n\tdisplay.clear()\n\n\tlocal projectedVertices = {}\n\t\n\t-- Loop through each verticy\n\tfor i = 1, #vertices do\n\t\t-- Get the current verticy and rotate it based on the x and y angles\n\t\tlocal rotatedVertex = vertices[i]:rotateX(angleX):rotateY(angleY)\n\t\t\n\t\t-- Project the rotated vertex to 2D screen space and add to the table\n\t\tlocal x, y = projectVertex(rotatedVertex)\n\t\tprojectedVertices[i] = {x, y}\n\tend\n\t\n\t-- Loop through each edge and draw a line btween the 2 vertices\n\tfor i = 1, #edges do\n\t\tlocal v1 = projectedVertices[edges[i][1]]\n\t\tlocal v2 = projectedVertices[edges[i][2]]\n\t\t\n\t\tdisplay.drawLine(v1[1], v1[2], v2[1], v2[2], color)\n\tend\n\n\tdisplay.update()\n\n\tangleX = angleX + rotationSpeed\n\tangleY = angleY + rotationSpeed\nend"
    },
    {
        "name": "Display - Touchscreen",
        "script": "local display = sc.getDisplays()[1]\nassert(display, \"Display not found! Make sure you have connected a Display to the computer!\")\n\nfunction onLoad()\n\tdisplay.enableTouchScreen(true)\nend\n\nfunction onUpdate()\n\tlocal data = display.getTouchData()\n\n\t-- 3 = Released\n\tif data and data.state ~= 3 then\n\t\tdisplay.drawPixel(data.x, data.y, sc.color.random0to1())\n\tend\n\t\n\tdisplay.update()\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    {
        "name": "Camera - Custom Picture Drawer",
        "script": "local display = sc.getDisplays()[1]\nassert(display, \"Display not found! Make sure you have connected a Display to the computer!\")\n\nlocal camera = sc.getCameras()[1]\nassert(display, \"Camera not found! Make sure you have connected a Camera to the computer!\")\n\nlocal function drawer(hit, result, x, y)\n\tif hit then\n\t\treturn sm.color.new(1, 1, 1) * (1 - result.fraction)\n\tend\n\n\treturn sm.color.new(\"000000\")\nend\n\nfunction onLoad()\n\tcamera.setFov(50) -- Fov in degrees\n\tcamera.setRange(1000) -- Range in meters\n\n\tcamera.customFrame(display, drawer)\n\tdisplay.update()\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    {
        "name": "Camera - Picture",
        "script": "local display = sc.getDisplays()[1]\nassert(display, \"Display not found! Make sure you have connected a Display to the computer!\")\n\nlocal camera = sc.getCameras()[1]\nassert(display, \"Camera not found! Make sure you have connected a Camera to the computer!\")\n\nfunction onLoad()\n\tcamera.setFov(50) -- Fov in degrees\n\tcamera.setRange(1000) -- Range in meters\n\n\tcamera.frame(display)\n\tdisplay.update()\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    {
        "name": "Camera - Video",
        "script": "local display = sc.getDisplays()[1]\nassert(display, \"Display not found! Make sure you have connected a Display to the computer!\")\n\nlocal camera = sc.getCameras()[1]\nassert(display, \"Camera not found! Make sure you have connected a Camera to the computer!\")\n\nfunction onLoad()\n\tcamera.setFov(50) -- Fov in degrees\n\tcamera.setRange(250) -- Range in meters\n\n\tdisplay.setOptimizationThreshold(0.05) -- Sets the image compression\nend\n\nfunction onUpdate()\n\tcamera.video(display, 4) -- 4 slices of the display will be drawn per tick\n\tdisplay.update()\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    {
        "name": "Speaker - Play Sound",
        "script": "local speaker = sc.getSpeakers()[1]\nassert(speaker, \"Speaker not found! Make sure you have connected a Speaker to the computer!\")\n\nfunction onLoad()\n\t-- See https://github.com/Vajdani/sm_docs/blob/master/Lists/Audio.json for full list\n\tspeaker.playSound(\"event:/music/robotheads/dance/dancebass\")\nend"
    },
    {
        "name": "Speaker - NBS Player",
        "script": "-- Convert a NBS file into base64 and put it into the string below and it should work.\nlocal nbsData = sc.base64.decode(\"RAW NBS DATA\")\n\nlocal speaker = sc.getSpeakers()[1]\nassert(speaker, \"Speaker not found! Make sure you have connected a Speaker to the computer!\")\n\nlocal player = sc.nbs.createPlayer(sc.nbs.loadNBS(nbsData), speaker)\n\nfunction onLoad()\n\tplayer:setLooped(true)\n\tplayer:start()\nend\n\nfunction onUpdate()\n\tplayer:update()\nend"
    },
    {
        "name": "Speaker - MIDI Player",
        "script": "-- Put ur converted MIDI data in this string! Don't convert the \" to ' or else you will get lua parser errors!\nlocal data = 'YOUR MIDI DATA'\n\nlocal speaker = sc.getSpeakers()[1]\nassert(speaker, \"Speaker not found! Make sure you have connected a Speaker to the computer!\")\n\nlocal player = sc.midi.createPlayer(sm.json.parseJsonString(data), speaker)\n\nfunction onLoad()\n\tplayer:toggleLoop(true)\n\tplayer:start()\nend\n\nfunction onUpdate()\n\tplayer:update()\nend"
    },
    {
        "name": "Keyboard - Typing Example",
        "script": "local keyboard = sc.getKeyboards()[1]\nassert(keyboard, \"Keyboard not found! Make sure you have connected a Keyboard to the computer!\")\n\nlocal display = sc.getDisplays()[1]\nassert(display, \"Display not found! Make sure you have connected a Display to the computer!\")\n\nlocal text = \"\"\nlocal lastKeystroke = \"\"\nlocal pressClock = nil\nlocal notPress = true\n\nfunction onUpdate()\n\tlocal keystroke = keyboard.getLatestKeystroke()\n\tlocal pressed = keyboard.isPressed()\n\tlocal clock = os.clock()\n\n\tlocal rapidPress = false\n\n\t-- Key handle logic\n\tif pressed then\n\t\tif keystroke == lastKeystroke then\n\t\t\tif not pressClock then\n\t\t\t\tpressClock = clock -- Set the pressClock\n\t\t\tend\n\n\t\t\tif pressClock + 0.3 <= clock then\n\t\t\t\trapidPress = true\n\t\t\tend\n\t\telse\n\t\t\tpressClock = nil -- Reset\n\t\tend\n\telse\n\t\tpressClock = nil -- Reset\n\t\tnotPress = true\n\tend\n\n\t-- Check if a key was pressed\n\tif (pressed and notPress or keystroke ~= lastKeystroke) or rapidPress then\n\t\tlastKeystroke = keystroke\n\t\tnotPress = false\n\n\t\t-- If backspace, then we have to remove a character\n\t\tif keystroke == \"backSpace\" then\n\t\t\ttext = text:sub(1, #text - 1)\n\t\telse\n\t\t\ttext = text .. keystroke\n\t\tend\n\n\t\t-- Update the display\n\t\tdisplay.clear()\n\t\tdisplay.drawText(2, 2, text, \"eeeeee\")\n\t\tdisplay.update()\n\tend\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend"
    },
    {
        "name": "Motor - Random Torque & Speed",
        "script": "local motor = sc.getMotors()[1]\n\nfunction onLoad()\n\t-- Set the bearing speed and torque to random values\n\tmotor.setBearingSpeed(math.random(100, 1000))\n\tmotor.setTorque(math.random(100, 1000))\nend"
    },
    {
        "name": "Laser - Object Detection",
        "script": "local laser = sc.getLasers()[1]\nlocal distance = 100 -- Distance that the laser can detect (in meters, 1m = 4 blocks)\n\nfunction onLoad()\n\tlaser.setDistance(distance)\nend\n\nfunction onUpdate()\n\tlocal hit, result = laser.getLaserData()\n\n\tif hit then\n\t\tlocal roundedDistance = math.floor(result.fraction * distance)\n\t\n\t\tprint(\"Hit! Distance is \"..roundedDistance.. \" Meter(s)\")\n\tend\nend"
    },
    {
        "name": "GPS - Print Speed",
        "script": "local gps  = sc.getGPSs()[1]\n\nfunction onUpdate()\n\tlocal data = gps.getGPSData()\n\n\tprint(\"Current Speed: \" .. math.floor(data.speed) .. \" m/s\")\nend"
    },
    {
        "name": "Gravity Controller - Zero Gravity",
        "script": "local gravityController = sc.getGravityControllers()[1]\nlocal multiplier = 0 -- Setting it to 0 makes it no gravity! 2 for double the gravitiy.\n\nfunction onLoad()\n\tgravityController.setGravityEnabled(true)\n\tgravityController.setMultiplier(multiplier)\nend\n\nfunction onDestroy()\n\tgravityController.setGravityEnabled(false)\nend"
    },
    {
        "name": "Light - Rainbow Light",
        "script": "local light = sc.getLights()[1]\n\nlocal rainbowColors = {\n\tsm.color.new(1, 0, 0), -- Red\n\tsm.color.new(1, 0.5, 0), -- Orange\n\tsm.color.new(1, 1, 0), -- Yellow\n\tsm.color.new(0, 1, 0), -- Green\n\tsm.color.new(0, 0, 1), -- Blue\n\tsm.color.new(0.29, 0, 0.51), -- Indigo\n\tsm.color.new(0.56, 0, 1) -- Violet\n}\ntable.insert(rainbowColors, rainbowColors[1])\n\nlocal gradient = sc.color.generateGradient(rainbowColors, 40 * 5)\nlocal gradientIndex = 1\n\nfunction onUpdate()\n\tgradientIndex = gradientIndex + 1\n\tif gradientIndex > #gradient then\n\t\tgradientIndex = 1\n\tend\n\n\tlight.setColor(gradient[gradientIndex])\nend\n\nfunction onDestroy()\n\tlight.setColor(sm.color.new(0, 0, 0))\nend"
    },
    {
        "name": "Registers - Addition",
        "script": "-- You need 2 input registers called \"input1\" and \"input2\" and you need a Output register called \"output\"\n-- For every trick it will do: output = input1 + input2\n\nfunction onUpdate()\n\tlocal input1 = sc.getReg(\"input1\")\n\tlocal input2 = sc.getReg(\"input2\")\n\n\tsc.setReg(\"output\", input1 + input2) \nend"
    },
    {
        "name": "Registers - Clock",
        "script": "-- You need a output register with the name \"output\" for this!\n\nlocal isEnabled = false\n\nfunction onUpdate()\n\tsc.setReg(\"output\", isEnabled)\n\tisEnabled = not isEnabled\nend"
    },
    {
        "name": "MultiDisplays - Whiteboard",
        "script": "local display = sc.multidisplay.new(sc.getDisplays(), 3, 2)\nlocal prevTouchTable = nil\nlocal usernameToColor = {}\n\nfunction onLoad()\n\tdisplay.clear()\n\tdisplay.update()\n\tdisplay.enableTouchScreen(true)\nend\n\nfunction onUpdate()\n\tlocal touchTable = display.getTouchTable()\n\n\tif sc.getReg(\"clear\") == 1 then\n\t\tdisplay.clear()\n\t\tdisplay.update()\n\tend\n\n\tif next(touchTable) ~= nil then\n\t\tfor username, data in pairs(touchTable) do\n\t\t\tusernameToColor[username] = usernameToColor[username] or sc.color.random0to1()\n\n\t\t\tif prevTouchTable and prevTouchTable[username] then\n\t\t\t\tlocal prevTouchData = prevTouchTable[username]\n\n\t\t\t\tdisplay.drawLine(data.x, data.y, prevTouchData.x, prevTouchData.y, usernameToColor[username])\n\t\t\telse\n\t\t\t\tdisplay.drawPixel(data.x, data.y, usernameToColor[username])\n\t\t\tend\n\t\tend\n\n\t\tprevTouchTable = touchTable\n\t\tdisplay.update()\n\telse\n\t\tprevTouchTable = nil\n\tend\nend\n\nfunction onDestroy()\n\tdisplay.clear()\n\tdisplay.update()\nend\n\n-- Connect a input register called \"clear\" & a button should be connected to it. Its so you can\n-- clear the whiteboard!\n\n-- NOTE: Expects a 2x3 display grid in this format. Left top right, Top to bottom."
    },
    {
        "name": "Games - PONG",
        "script": "-- This is the game PONG, For the bare mininum, connect a display to the computer\n-- A 128x128 display is recommended.\n--\n-- Additional components you could connect:\n--\t  Speaker: Connecting a speaker adds sound effects to the game.\n--\t  Input registers: (Connect any of these input registers to the computer with 1 of the name's bellow will add functionaility)\n--\t\t  \"reset\": Lets you reset the game\n--\t\t  \"aiMode\": Lets you toggle a gamemode where its AI vs AI.\n--\t\t  \"debugMode\": If enabled, it shows the ball's direction & 2 lines on the player pad to give you information if the ball's y cordinates fits in your pad.\n\n-- SOURCE CODE --\n\nlocal display = sc.getDisplays()[1]\nlocal speaker = sc.getSpeakers()[1]\n\nif not display then\n\terror(\"Please connect a display!\")\nend\n\nlocal gameState = 0\nlocal playerY = 75\nlocal aiY = 75\nlocal speed = 0.5\nlocal aiSpeed1 = 0.2\nlocal aiErrorMargin1 = 3\nlocal aiSpeed2 = 0.2\nlocal aiErrorMargin2 = 3\nlocal padHeight = 16\nlocal screenHeight, screenWidth = display.getDimensions()\nlocal ballX = screenWidth / 2\nlocal ballY = screenHeight / 2\nlocal ballSpeedX = 1.25\nlocal ballSpeedY = 1.25\nlocal ballRadius = 2\nlocal playerScore = 0\nlocal aiScore = 0\nlocal maxScore = 10\nlocal maxBounceAngle = math.rad(85)\nlocal clock = 0\n\nlocal currentisAIvsAIMode = false\n\nlocal minBallSpeed = 0.75\n\nif not speaker then\n\tspeaker = {beep = function() end, longBeep = function() end}\nend\n\nfunction getRegValue(name, defaultValue)\n\tlocal success, result = pcall(sc.getReg, name)\n\tif not success then\n\t\treturn defaultValue\n\tend\n\n\treturn result\nend\n\nfunction enforceMinimumBallSpeed()\n\tlocal ballSpeed = math.sqrt(ballSpeedX^2 + ballSpeedY^2)\n\tif ballSpeed < minBallSpeed then\n\t\tlocal scale = minBallSpeed / ballSpeed\n\t\tballSpeedX = ballSpeedX * scale\n\t\tballSpeedY = ballSpeedY * scale\n\tend\nend\n\nfunction reSkillAIs()\n\taiSpeed1 = 0.15 + math.random() * 0.2\n\taiSpeed2 = 0.15 + math.random() * 0.2\n\taiErrorMargin1 = 2 + math.random() * 3\n\taiErrorMargin2 = 2 + math.random() * 3\n\tspeed = 0.1 + math.random()\nend\n\nfunction resetBall()\n\tballX = screenWidth / 2\n\tballY = screenHeight / 2\n\tballSpeedX = 1.25 * ((math.random() > 0.5) and 1 or -1)\n\tballSpeedY = 1.25 * ((math.random() > 0.5) and 1 or -1)\nend\n\nfunction checkGameOver()\n\tif currentisAIvsAIMode then\n\t\tif playerScore >= maxScore then return \"AI #1 Wins!\" elseif aiScore >= maxScore then return \"AI #2 Wins!\" end\n\t\treturn\n\tend\n\tif playerScore >= maxScore then return \"Player Wins!\" elseif aiScore >= maxScore then return \"AI Wins!\" end\nend\n\nfunction modifyBounceAngle(paddleY, ballY, padHeight)\n\tlocal relativeIntersectY = (ballY - paddleY) / (padHeight / 2)\n\tlocal bounceAngle = relativeIntersectY * maxBounceAngle\n\treturn bounceAngle\nend\n\nfunction updateBallDirectionAfterPaddleHit(paddleY, ballY, padHeight)\n\tlocal bounceAngle = modifyBounceAngle(paddleY, ballY, padHeight)\n\tlocal ballSpeed = math.sqrt(ballSpeedX^2 + ballSpeedY^2)\n\tballSpeedX = ballSpeed * math.cos(bounceAngle)\n\tballSpeedY = ballSpeed * math.sin(bounceAngle)\n\n\tspeaker.beep()\nend\n\nfunction onLoad()\n\tdisplay.enableTouchScreen(true)\n\tresetBall()\nend\n\nfunction onUpdate()\n\tdebugMode = getRegValue(\"debugMode\", 0) == 1\n\n\tif getRegValue(\"reset\", 0) == 1 then\n\t\tplayerScore = 0\n\t\taiScore = 0\n\t\taiY = 75\n\t\tplayerY = 75\n\t\tresetBall()\n\t\tgameState = 0\n\t\tclock = 0\n\t\treturn\n\tend\n\n\tif gameState == 0 then\n\t\tlocal width, height = display.calcTextSize(\"Touch to play!\")\n\t\tdisplay.clear()\n\t\tdisplay.drawText((screenWidth / 2) - (width / 2), (screenHeight / 2) - (height / 2), \"Touch to play!\")\n\t\t\n\t\tif getRegValue(\"aiMode\", 0) == 1 then\n\t\t\tdisplay.drawText(4, 4, \"AI vs AI Mode\", \"00ee00\")\n\t\tend\n\t\t\n\t\tdisplay.update()\n\t\tlocal touchData = display.getTouchData()\n\t\tif touchData then\n\t\t\tgameState = 1\n\t\t\tplayerY = touchData.y\n\n\t\t\tplayerScore = 0\n\t\t\taiScore = 0\n\t\t\taiY = 75\n\t\t\tplayerY = 75\n\n\t\t\tcurrentisAIvsAIMode = getRegValue(\"aiMode\", 0) == 1\n\t\t\tspeed = 0.5\n\t\t\tballSpeedX = currentisAIvsAIMode and 1.25 or 1\n\t\t\tballSpeedY = currentisAIvsAIMode and 1.25 or 1\n\t\t\t\n\t\t\tif currentisAIvsAIMode then\n\t\t\t\treSkillAIs()\n\t\t\telse\n\t\t\t\taiSpeed1 = 0.2\n\t\t\tend\n\t\tend\n\telseif gameState == 1 then\n\t\tlocal touchData = display.getTouchData()\n\n\t\tif not currentisAIvsAIMode and touchData then\n\t\t\tlocal newY = sm.util.clamp(touchData.y, padHeight / 2, screenHeight - padHeight / 2)\n\t\t\tplayerY = playerY + (newY - playerY) * speed\n\t\tend\n\n\t\tif currentisAIvsAIMode then\n\t\t\tlocal targetPlayerY = ballY + aiErrorMargin2 * (math.random() - 0.5)\n\t\t\tplayerY = playerY + (targetPlayerY - playerY) * aiSpeed2\n\t\t\tplayerY = sm.util.clamp(playerY, padHeight / 2, screenHeight - padHeight / 2)\n\n\t\t\tlocal targetAiY = ballY + aiErrorMargin1 * (math.random() - 0.5)\n\t\t\taiY = aiY + (targetAiY - aiY) * aiSpeed1\n\t\t\taiY = sm.util.clamp(aiY, padHeight / 2, screenHeight - padHeight / 2)\n\t\telse\n\t\t\tlocal targetAiY = ballY + aiErrorMargin1 * (math.random() - 0.5)\n\t\t\taiY = aiY + (targetAiY - aiY) * aiSpeed1\n\t\t\taiY = sm.util.clamp(aiY, padHeight / 2, screenHeight - padHeight / 2)\n\t\tend\n\n\t\tballX = ballX + ballSpeedX\n\t\tballY = ballY + ballSpeedY\n\t\t\n\t\tif ballY - ballRadius < 0 then\n\t\t\tballY = ballRadius\n\t\t\tballSpeedY = -ballSpeedY\n\t\t\t\n\t\t\tif currentisAIvsAIMode then\n\t\t\t\tballSpeedY = ballSpeedY + ((0.85 - math.random()) * 2)\n\t\t\telse\n\t\t\t\tballSpeedX = ballSpeedX * 1.05\n\t\t\t\tballSpeedY = ballSpeedY * 1.05\n\t\t\tend\n\n\t\t\tenforceMinimumBallSpeed()\n\t\t\tspeaker.beep()\n\t\telseif ballY + ballRadius > screenHeight then\n\t\t\tballY = screenHeight - ballRadius\n\t\t\tballSpeedY = -ballSpeedY\n\n\t\t\tif currentisAIvsAIMode then\n\t\t\t\tballSpeedY = ballSpeedY + ((0.85 - math.random()) * 2)\n\t\t\telse\n\t\t\t\tballSpeedX = ballSpeedX * 1.05\n\t\t\t\tballSpeedY = ballSpeedY * 1.05\n\t\t\tend\n\n\t\t\tenforceMinimumBallSpeed()\n\t\t\tspeaker.beep()\n\t\tend\n\n\t\tlocal playerPaddleLeft = 10\n\t\tlocal playerPaddleRight = playerPaddleLeft + 4\n\t\tlocal playerPaddleTop = playerY - padHeight / 2\n\t\tlocal playerPaddleBottom = playerY + padHeight / 2\n\n\t\tlocal aiPaddleLeft = screenWidth - 14\n\t\tlocal aiPaddleRight = aiPaddleLeft + 4\n\t\tlocal aiPaddleTop = aiY - padHeight / 2\n\t\tlocal aiPaddleBottom = aiY + padHeight / 2\n\t\t\n\t\tlocal ballLeft = ballX - ballRadius\n\t\tlocal ballRight = ballX + ballRadius\n\t\tlocal ballTop = ballY - ballRadius\n\t\tlocal ballBottom = ballY + ballRadius\n\n\t\tif ballRight > playerPaddleLeft and ballLeft < playerPaddleRight and ballBottom > playerPaddleTop and ballTop < playerPaddleBottom then\n\t\t\tupdateBallDirectionAfterPaddleHit(playerY, ballY, padHeight)\n\t\t\tballSpeedX = math.abs(ballSpeedX)\n\n\t\t\tif not currentisAIvsAIMode then\n\t\t\t\tballSpeedX = ballSpeedX * 1.05\n\t\t\t\tballSpeedY = ballSpeedY * 1.05\n\t\t\tend\n\n\t\t\tenforceMinimumBallSpeed()\n\t\tend\n\t\t\n\t\tif ballLeft < aiPaddleRight and ballRight > aiPaddleLeft and ballBottom > aiPaddleTop and ballTop < aiPaddleBottom then\n\t\t\tupdateBallDirectionAfterPaddleHit(aiY, ballY, padHeight)\n\t\t\tballSpeedX = -math.abs(ballSpeedX)\n\n\t\t\tif not currentisAIvsAIMode then\n\t\t\t\tballSpeedX = ballSpeedX * 1.05\n\t\t\t\tballSpeedY = ballSpeedY * 1.05\n\t\t\tend\n\n\t\t\tenforceMinimumBallSpeed()\n\t\tend\n\t\t\n\t\tif ballLeft < 0 then\n\t\t\taiScore = aiScore + 1\n\t\t\tresetBall()\n\t\t\tspeaker.longBeep()\n\t\telseif ballRight > screenWidth then\n\t\t\tplayerScore = playerScore + 1\n\t\t\tresetBall()\n\t\t\tspeaker.longBeep()\n\t\tend\n\n\t\tlocal gameOverMessage = checkGameOver()\n\t\tif gameOverMessage then\n\t\t\tgameState = 2\n\t\tend\n\n\t\tdisplay.clear()\n\t\tif debugMode then\n\t\t\tdisplay.drawLine(1, playerY + (padHeight / 2), screenWidth, playerY + (padHeight / 2), \"888888\")\n\t\t\tdisplay.drawLine(1, playerY - (padHeight / 2), screenWidth, playerY - (padHeight / 2), \"888888\")\n\t\tend\n\t\tdisplay.drawFilledRect(10, playerY - padHeight / 2, 4, padHeight, \"eeeeee\")\n\t\tdisplay.drawFilledRect(screenWidth - 14, aiY - padHeight / 2, 4, padHeight, \"eeeeee\")\n\n\t\tfor i = 1, screenHeight, 1 do\n\t\t\tif i % 2 == 0 then\n\t\t\t\tdisplay.drawPixel(screenWidth / 2, i, \"eeeeee\")\n\t\t\tend\n\t\tend\n\n\t\tif debugMode then\n\t\t\tlocal lineEndX = ballX\n\t\t\tlocal lineEndY = ballY\n\t\t\n\t\t\tif ballSpeedX < 0 then\n\t\t\t\tlocal timeToPaddle = (10 - (ballX - ballRadius)) / ballSpeedX\n\t\t\t\tlineEndX = 10\n\t\t\t\tlineEndY = ballY + ballSpeedY * timeToPaddle\n\t\t\n\t\t\telseif ballSpeedX > 0 then\n\t\t\t\tlocal timeToPaddle = (screenWidth - 14 - (ballX + ballRadius)) / ballSpeedX\n\t\t\t\tlineEndX = screenWidth - 14\n\t\t\t\tlineEndY = ballY + ballSpeedY * timeToPaddle\n\t\t\tend\n\t\t\n\t\t\tdisplay.drawLine(ballX, ballY, lineEndX, lineEndY, \"eeee00\")\n\t\tend\n\n\t\tdisplay.drawFilledRect(ballX - ballRadius, ballY - ballRadius, ballRadius * 2, ballRadius * 2, \"ee0000\")\n\t\tdisplay.drawText(10, 5, tostring(playerScore))\n\t\tdisplay.drawText(screenWidth - 14, 5, tostring(aiScore))\n\n\t\tdisplay.update()\n\telseif gameState == 2 then\n\t\tlocal gameOverMessage = checkGameOver()\n\t\tlocal width, height = display.calcTextSize(gameOverMessage)\n\t\tdisplay.clear()\n\t\tdisplay.drawText((screenWidth / 2) - (width / 2), (screenHeight / 2) - (height / 2), gameOverMessage)\n\t\tdisplay.update()\n\t\t\n\t\tclock = clock + 1\n\t\tif clock == 5 * 50 then\n\t\t\tclock = 0\n\t\t\tgameState = 0\n\t\tend\n\tend\nend\n\n-- Please scroll to the top for information!"
    }
]